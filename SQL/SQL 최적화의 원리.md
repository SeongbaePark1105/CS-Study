# SQL 최적화의 원리

### 1. 옵티마이저와 실행 계획

#### ① 옵티마이저(Optimizer)

- 옵티마이저는 SQL을 어떻게 실행할 것인지를 계획하게 됨
  - 즉, SQL 실행 계획을 수립하고 SQL을 실행함
- 옵티마이저는 SQL의 실행 계획을 수립하고 SQL을 실행하는 데이터베이스 관리 시스템의 소프트웨어임
- 동일한 결과가 나오는 SQL도 어떻게 실행하느냐에 따라서 성능이 달라짐
- 따라서 옵티마이저의 실행 계획은 SQL 성능에 아주 중요한 역할임

#### ② 옵티마이저 특징

- 데이터 딕셔너리에 있는 오브젝트 통계, 시스템 통계 등의 정보를 사용해서 예상되는 비용 산정
- 여러 개의 실행 계획 중에서 최저비용을 가지고 있는 계획을 선택해서 SQL을 실행

#### ③ 옵티마이저의 필요성

- 힌트를 사용하여 옵티마이저에게 실행 계획을 변경하도록 요청할 수 있음

- 예를 들어 EMP테이블과 DEPT 테이블이 있음

  - EMP 테이블이 더 큰데 해당 테이블을 읽고 DEPT 테이블을 읽으면 불필요하게 비교 횟수가 증가하게 됨
  - 따라서, DEPT 테이블을 먼저 읽고 EMP 테이블을 먼저 읽게 되면 비교 횟수를 줄일 수 있음

- ##### TABLE ACCESS FULL

  - 테이블의 전체를 읽었다는 뜻



### 2. 옵티마이저 종류

#### ① 옵티마이저 실행 방법

- <b>개발자 SQL</b> -> <b>Parsing (SQL 문법 검사, 구문 분석)</b> -> <b>규칙 or 비용 기반 옵티마이저</b> (기본적으로 비용 기반 옵티마이저 실행) -> <b>실행 계획</b> -> <b>SQL 실행</b>

#### ② 옵티마이저 엔진

##### ▶옵티마이저 우선 순위

- ##### 1

  - ROWID를 사용한 단일 행인 경우

- ##### 2

  - 클러스터 조인에 의한 단일 행인 경우

- ##### 3

  - 유일하거나 기본키를 가진 해시 클러스터 키에 의한 단일 행인 경우

- ##### 4

  - 유일하거나 기본키에 의한 단일 행인 경우

- ##### 5

  - 클러스터 조인인 경우

- ##### 6

  - 해시 클러스터 조인인 경우

- ##### 7

  - 인덱스 클러스터 키인 경우

- ##### 8

  - 복합 칼럼 인덱스인 경우

- ##### 9

  - 단일 칼럼 인덱스인 경우

- ##### 10

  - 인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우

- ##### 11

  - 인덱스가 구성된 칼럼에서 무제한 범위를 검색하는 경우

- ##### 12

  - 정렬-병합 조인인 경우

- ##### 13

  - 인덱스가 구성된 칼럼에서 MAX 혹은 MIN을 구하는 경우

- ##### 14

  - 인덱스가 구성된 칼럼에서 ORDER BY를 실행하는 경우

- ##### 15

  - 전체 테이블을 스캔하는 경우

#### ③ 비용 기반 옵티마이저

- 오브젝트 통계 및 시스템 통계를 사용해서 총비용을 계산

- ##### 총비용

  - SQL문을 실행하기 위해서 예상되는 소요시간 혹은 자원의 사용량을 의미

- 총비욕이 적은 쪽으로 실행 계획을 수립한다.

  - 단, 비용 기반 옵티마이저에서 통계정보가 부적절한 경우 성능 저하가 발생



### 3. 인덱스

#### ① 인덱스

- 데이터를 빠르게 검색할 수 있는 방법을 제공

- 인덱스 키로 정렬되어 있기 대문에 원하는 데이터를 빠르게 조회 함

- 오름차순 및 내림차순으로 탐색이 가능

- 하나의 테이블에 여러 개의 인덱스를 생성할 수 있고 하나의 인덱스는 여러 개의 칼럼으로 구성될 수 있음

- 테이블을 생성할 때 기본키는 자동으로 인덱스가 만들어지고 인덱스의 이름은 <b>SYSXXX</b>임

- 인덱스의 구조는 <b>Root Block, Branch Block, Leaf Block</b>으로 구성됨

- ##### Root Block

  - 인덱스 트리에서 가장 상위에 있는 노드를 의미

- ##### Branch Block

  - 다음 단계의 주소를 가지고 있는 <b>포인터</b>로 되어 있음

- ##### Leaf Block

  - <b>인덱스 키</b>와 <b>ROWID</b>로 구성되고 인덱스 키는 정렬되어 저장되어 있음
  - <b>Double Linked List</b>형태로 되어 있어서 <b>양방향 탐색</b>이 가능
  - 인덱스 키를 읽으면 <b>ROWID</b>를 사용해서 해당 테이블의 행을 직접 읽을 수 있음

#### ② 인덱스 생성

- 인덱스 생성은 <b>CREATE INDEX</b>문을 사용해서 생성이 가능

- 인덱스를 생성할 때는 한 개 이상의 칼럼을 사용해서 생성할 수 있음

- 인덱스 키는 기본적으로 오름차순으로 정렬하고 <b>DESC</b>구를 포함하면 내림차순으로 정렬함

  ```sql
  CREATE INDEX 인덱스명 ON
  		테이블명(칼럼 ASC, 칼럼 DESC, 칼럼 ...)
  ```

  - 각 칼럼마다 내림차순 정렬로 할 것인지 오름차순으로 정렬 할 것인지 정할 수 있음
  - ASC는 생략 가능

#### ③ 인덱스 스캔

1. ##### 인덱스 유일 스캔 (Index Unique Scan)

   - 인덱스의 키 값이 중복되지 않는 경우, 해당 인덱스를 사용할 때 발생됨
   - 예르 들어 EMPNO(사원번호)가 중복되지 않는 경우 특정 하나의 EMPNO를 조회 함

2. ##### 인덱스 범위 스캔 (Index Range Scan)

   - <b>SELECT</b>문에서 특정 범위를 조회하는 <b>WHERE문</b>을 사용할 경우 발생
   - <b>LIKE, BETWEEN</b>이 그 대표적인 예
   - 물론 데이터 양이 적은 경우는 인덱스 자체를 실행하지 않고 <b>TABLE FULL SCAN</b>이 될 수 있음
   - <b>Index Range Scan</b>은 인덱스의 <b>Leaf Block</b>의 특정 범위를 스캔한 것

3. ##### 인덱스 전체 스캔 (Index Full Scan)

   - 인덱스에서 검색되는 인덱스 키가 많은 경우에 <b>Leaf Block</b>의 처음부터 끝까지 전체를 읽음

- <b>Table Full Scan</b> 시에 <b>High WaterMark</b>의 의미
  - <b>Table Full Scan</b>은 테이블의 데이터를 모두 읽은 것을 의미
  - 테이블을 읽을 때 <b>High WaterMark</b>이하까지만 <b>Table Full Scan</b>을 함
  - <b>High WaterMark</b>는 <b>테이블에 데이터가 저장된 블록에서 최상위 위치</b>를 의미하고
    데이터가 삭제되면 <b>High WaterMark</b>가 변경됨



### 4. 실행 계획

- <b>Nested Loop</b> 방식의 조인은 선행 테이블에서 먼저 데이터를 찾고 그 다음 테이블을 찾는 것을 의미
  - 이 것을 <b>Random Access</b>라고 함



### 5. 옵티마이저 조인

#### ① Nested Loop 조인

- 하나의 테이블에서 데이터를 먼저 찾고 그 다음 테이블을 조인하는 방식으로 실행 됨
- 먼저 조회되는 테이블을 <b>Outer Table</b>, 그 다음에 조회되는 테이블을 <b>Inner Table</b>
- <b>Nested Loop 조인</b>에서는 외부 테이블의 크기가 작은 것을 먼저 찾는 것이 중요
  - 그래야 데이터가 스캔되는 범위를 줄일 수 있기 때문
- <b>Nested Loop 조인</b>은 <b>RANDOM ACCESS</b>가 발생하는데 많이 발생하면 성능 지연이 발생
  - 그러므로 <b>RANDOM ACCESS</b>의 양을 줄여야 성능이 향상

#### ② Sort Merge 조인

- 두 개의 테이블을 <b>SORT_AREA</b>라는 메모리 공간에 모두 로딩하고 <b>SORT</b>를 수행

- 두 개의 테이블에 대해서 <b>SORT</b>가 완료되면 두 개의 테이블을 <b>병합(Merge)</b>함

- 정렬(SORT)가 발생하기 때문에 데이터 양이 많아지면 성능이 떨어지게 됨

- 정렬 데이터 양이 너무 많으면 정렬은 <b>임시 영역</b>에서 수행

- ##### 임시 영역

  - 디스크에 있기 때문에 성능이 급격히 떨어짐

#### ③ Hash 조인

- 두 개의 테이블 중에서 작은 테이블을 <b>HASH 메모리</b>에 로딩하고 두 개의 테이블의 조인 키를 사용해서 헤시 테이블을 행성
- <b>Hash 조인</b>은 해시 함수를 사용해서 주소를 계산하고 해당 주소를 사용해서 테이블을 조인하기 때문에 <b>CPU 연산</b>을 많이 사용
- 특히 <b>Hash 조인</b> 시에는 선행 테이블이 충분히 메모리에 로딩되는 크기여야 함

- <b>Equal Join</b>만 사용 가능