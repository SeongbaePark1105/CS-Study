# [JPA] 영속성 관리 - 내부 동작 방식

## JPA에서 가장 중요한 2가지

- 객체와 관계형 데이터베이스 매핑하기
- <b>영속성 컨텍스트</b>



### [ 영속성 컨텍스트 ]

- JPA를 이해하는데 가장 중요한 용어이다.
- <span style ="color:red">엔티티를 영구 저장하는 환경</span>이라는 뜻
- <b>EntitiyManager.persist(entity)</b>

##### 영속성 컨텍스트의 이점

- 1차 캐시

  - 한번 조회하거나 `persits` 한 것을 1차 캐시에 저장시켜 동일한 트랙잭션에서 조회 할 때에는 DB에서 찾아오지 않고 1차 캐시에서 검색해서 가져온다.

  ![image-20230801212540914](C:\Users\sbpar\AppData\Roaming\Typora\typora-user-images\image-20230801212540914.png)

- 동일성 보장

  ```
  Member findMember1 = em.find(Member.class, 101L);
  Member findMember2 = em.find(Member.class, 101L);
  findMember1 == findMember2 -> true 의 값을 가진다.
  ```

- 트랜잭션을 지원하는 쓰기 지연

- 변경 감지

  - DB에서 찾은 값을 객체에 저장하고 객체의 값을 다시 변경했을 때 JPA가 자동으로 감지하여 `update`쿼리를 날림
  - JPA는 컬렉션과 비슷하게 다루기 때문에 값을 꺼낸 뒤에 값을 변경 했을 때 자동으로 바꾸고 DB에 변경 된 것을 넣어 준다.
  - 영속 컨텍스트에서 최초로 값을 읽어놓은 시점에서 스냅샷이라는 걸 만들어서 최초의 값들을 저장해놓는다.
  - 값이 변경 되었을 때 JPA가 Entity와 스냅샷을 비교를 한다.
  - 여기서 값이 변경 되었을 때는 쓰기 지연 SQL 저장소에 반영하게 된다.
  - 그 다음에 DB에 커밋을 하게 된다.
  - 엔티티 삭제도 이와 동일하게 이루어진다.
  - JPA는 값이 변경되면 트랜잭션이 커밋되는 시점에 변경이 된다고 생각하면 될 것 같다.

  ![image-20230801212620714](C:\Users\sbpar\AppData\Roaming\Typora\typora-user-images\image-20230801212620714.png)

- 지연 로딩

##### 엔티티의 생명 주기

-  <b>비영속</b>
  - 영속성 컨텍스트와 전혀 관계가 없는 <b>새로운</b> 상태
- <b>영속</b>
  - 영속성 컨텍스트에 <b>관리</b>되는 상태
  - `persits`해서 컨텍스트에 넣은 것
  - `find` 같은 걸로 가져온 상태
- <b>준영속</b>
  - 영속성 컨텍스트에 저장되었다가 <b>분리</b>된 상태
  - `detach`를 사용해서 해당 엔티티를 영속성 컨텍스트에서 <b>분리</b>시킨 상태
  - `준영속 상태로 만드는 법`
    - `em.detach(entity)`
      - 특정 엔티티만 준영속 상태로 전환
    - `em.clear()`
      - 영속성 컨텍스트를 완전히 초기화
    - `em.close()`
      - 영속성 컨텍스를 종료
- <b>삭제</b>
  - <b>삭제</b>된 상태
  - `remove`로 삭제

##### 플러시

- 영속성 컨텍스트를 비우지 않음
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 하는 것
- 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 됨

